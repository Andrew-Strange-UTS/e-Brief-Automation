name: Non-Prod mailman automation

on:
  workflow_dispatch:

jobs:
  mailman-automation:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install requirements (jq, Python, Selenium, Chrome)
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip jq chromium-browser
          python3 -m pip install --upgrade pip
          pip3 install selenium webdriver-manager

      # Step 1: Fetch relevant ServiceNow tasks into 6 groups
      - name: Fetch ServiceNow tasks grouped by type
        id: fetch-tasks
        env:
          SN_USER: ${{ secrets.SERVICECONNECT_USERNAME }}
          SN_PASS: ${{ secrets.SERVICECONNECT_PASSWORD }}
        run: |
          DESCS=("Add user to CASS ebrief." "Remove user to CASS ebrief." "Add user to Academic ebrief" "Remove user Academic ebrief" "Add user to non-Academic ebrief" "Remove user from non-Academic ebrief")
          ARRAY_NAMES=(CASS_ADD CASS_REMOVE ACAD_ADD ACAD_REMOVE NACAD_ADD NACAD_REMOVE)
          for i in {0..5}; do
            DESC="${DESCS[$i]}"
            NAME="${ARRAY_NAMES[$i]}"
            QUERY="active=true^state=1^short_description=$DESC"
            ENCODED_QUERY=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${QUERY}'))")
            URL="https://utsdevesm.service-now.com/api/now/table/sc_task?sysparm_query=${ENCODED_QUERY}&sysparm_fields=number"
            RESP=$(curl -s -u "$SN_USER:$SN_PASS" -H "Accept: application/json" "$URL")
            ARR=$(echo "$RESP" | jq -c '[.result[].number]')
            echo "Fetched $NAME numbers: $ARR"
            echo "$NAME=$ARR" >> $GITHUB_ENV
          done

      # Step 2: For each group, fetch email addresses and print arrays as [task, email]
      - name: Fetch emails for all tasks for each group
        id: fetch-emails
        env:
          SN_USER: ${{ secrets.SERVICECONNECT_USERNAME }}
          SN_PASS: ${{ secrets.SERVICECONNECT_PASSWORD }}
          CASS_ADD: ${{ env.CASS_ADD }}
          CASS_REMOVE: ${{ env.CASS_REMOVE }}
          ACAD_ADD: ${{ env.ACAD_ADD }}
          ACAD_REMOVE: ${{ env.ACAD_REMOVE }}
          NACAD_ADD: ${{ env.NACAD_ADD }}
          NACAD_REMOVE: ${{ env.NACAD_REMOVE }}
        run: |
          fetch_emails() {
            local arr_name="$1"
            local nums_json="$2"
            nums=$(echo "$nums_json" | jq -r '.[]')
            declare -a output_arr=()
            for num in $nums; do
              RITM_SYSID=$(curl -s -u "$SN_USER:$SN_PASS" \
                -H "Accept: application/json" \
                "https://utsdevesm.service-now.com/api/now/table/sc_task?sysparm_query=number=${num}&sysparm_fields=request_item" \
                | jq -r '.result[0].request_item.value // empty')
              [ -z "$RITM_SYSID" ] && output_arr+=( "[\"$num\",\"error-No request_item\"]" ) && continue
              REQ_FOR_SYSID=$(curl -s -u "$SN_USER:$SN_PASS" \
                -H "Accept: application/json" \
                "https://utsdevesm.service-now.com/api/now/table/sc_req_item?sysparm_query=sys_id=${RITM_SYSID}&sysparm_fields=requested_for" \
                | jq -r '.result[0].requested_for.value // empty')
              [ -z "$REQ_FOR_SYSID" ] && output_arr+=( "[\"$num\",\"error-No requested_for\"]" ) && continue
              EMAIL=$(curl -s -u "$SN_USER:$SN_PASS" \
                -H "Accept: application/json" \
                "https://utsdevesm.service-now.com/api/now/table/sys_user?sysparm_query=sys_id=${REQ_FOR_SYSID}&sysparm_fields=email" \
                | jq -r '.result[0].email // empty')
              [ -z "$EMAIL" ] && output_arr+=( "[\"$num\",\"error-Email not found\"]" ) && continue
              output_arr+=( "[\"$num\",\"$EMAIL\"]" )
            done
            if (( ${#output_arr[@]} )); then
              printf -v finalarr '[%s]' "$(IFS=,; echo "${output_arr[*]}")"
            else
              finalarr='[]'
            fi
            echo "Email pairs for $arr_name: $finalarr"
            echo "${arr_name}_EMAILS=$finalarr" >> $GITHUB_ENV
          }
          fetch_emails "CASS_ADD" "$CASS_ADD"
          fetch_emails "CASS_REMOVE" "$CASS_REMOVE"
          fetch_emails "ACAD_ADD" "$ACAD_ADD"
          fetch_emails "ACAD_REMOVE" "$ACAD_REMOVE"
          fetch_emails "NACAD_ADD" "$NACAD_ADD"
          fetch_emails "NACAD_REMOVE" "$NACAD_REMOVE"

      # Step 3: Build the main 6x3 array [[tasks],[emails],[responses]]
      - name: Build main array structure for mailman work
        id: build-main-array
        run: |
          groups=("CASS_ADD" "CASS_REMOVE" "ACAD_ADD" "ACAD_REMOVE" "NACAD_ADD" "NACAD_REMOVE")
          main_array="["
          for i in "${!groups[@]}"; do
            val="${groups[$i]}_EMAILS"
            arr_json="${!val}"
            tasks=$(echo "$arr_json" | jq '[.[].0]')
            emails=$(echo "$arr_json" | jq '[.[].1]')
            responses="[]"
            group_part="[$tasks,$emails,$responses]"
            main_array+="$group_part"
            if [ "$i" -lt 5 ]; then main_array+=","; fi
          done
          main_array+="]"
          echo "$main_array" > mailman_main_array.json
          cat mailman_main_array.json

      # Step 4: Run mailman scripts, update main array with responses
      - name: Add/remove members for all lists and fill in responses
        env:
          CASS_ADD_PW: ${{ secrets.CASS_PASSWORD }}
          CASS_REMOVE_PW: ${{ secrets.CASS_PASSWORD }}
          ACAD_ADD_PW: ${{ secrets.ACAD_PASSWORD }}
          ACAD_REMOVE_PW: ${{ secrets.ACAD_PASSWORD }}
          NACAD_ADD_PW: ${{ secrets.NACAD_PASSWORD }}
          NACAD_REMOVE_PW: ${{ secrets.NACAD_PASSWORD }}
        run: |
          #!/bin/bash
          set -e
          urls=(
            "https://<CASS_MAILMAN_URL>/add"
            "https://<CASS_MAILMAN_URL>/remove"
            "https://<ACAD_MAILMAN_URL>/add"
            "https://<ACAD_MAILMAN_URL>/remove"
            "https://<NACAD_MAILMAN_URL>/add"
            "https://<NACAD_MAILMAN_URL>/remove"
          )
          pws=(
            "$CASS_ADD_PW"
            "$CASS_REMOVE_PW"
            "$ACAD_ADD_PW"
            "$ACAD_REMOVE_PW"
            "$NACAD_ADD_PW"
            "$NACAD_REMOVE_PW"
          )
          # Prep output array
          updated_main_array="["
          for idx in {0..5}; do
            arr=$(jq ".[$idx]" mailman_main_array.json)
            tasks=($(echo "$arr" | jq -r '.[0][]'))
            emails=($(echo "$arr" | jq -r '.[1][]'))
            responses=()
            for j in "${!emails[@]}"; do
              email="${emails[$j]}"
              # skip empty/error emails
              if [[ "$email" == error* ]]; then
                resp="error-email-lookup"
              else
                if [[ $idx =~ ^(0|2|4)$ ]]; then
                  resp=$(python3 scripts/add_member_from_listserv.py "$email" "${urls[$idx]}" "${pws[$idx]}")
                else
                  resp=$(python3 scripts/remove_member_from_listserv.py "$email" "${urls[$idx]}" "${pws[$idx]}")
                fi
              fi
              # support if response is multiline
              resp=$(echo "$resp" | sed ':a;N;$!ba;s/\n/\\n/g')
              responses+=("\"$resp\"")
            done
            joined_responses=$(printf "%s," "${responses[@]}")
            # Remove trailing comma
            joined_responses="[${joined_responses%,}]"
            tasks_json=$(echo "$arr" | jq '.[0]')
            emails_json=$(echo "$arr" | jq '.[1]')
            group="[${tasks_json},${emails_json},${joined_responses}]"
            if [ $idx -eq 0 ]; then
              updated_main_array+="$group"
            else
              updated_main_array+=",$group"
            fi
          done
          updated_main_array+="]"
          echo "$updated_main_array" > mailman_main_array_with_results.json
          cat mailman_main_array_with_results.json

      # Step 5: Update ServiceNow sc_task with the FINAL results and close/annotate task where required
      - name: Update ServiceNow tasks with results
        env:
          SN_USER: ${{ secrets.SERVICECONNECT_USERNAME }}
          SN_PASS: ${{ secrets.SERVICECONNECT_PASSWORD }}
        run: |
          update_task() {
            local TASK="$1"; local NOTE="$2"; local RESULT="$3"
            curl -s -u "$SN_USER:$SN_PASS" \
              --request PATCH \
              --header "Content-Type: application/json" \
              --data "{\"work_notes\": \"$NOTE\"}" \
              "https://utsdevesm.service-now.com/api/now/table/sc_task?sysparm_query=number=${TASK}" > /dev/null
            if [[ ! "$RESULT" =~ ^error ]]; then
              curl -s -u "$SN_USER:$SN_PASS" \
                --request PATCH \
                --header "Content-Type: application/json" \
                --data '{"state":"3","cmdb_ci":{"display_value":"Listserv"}}' \
                "https://utsdevesm.service-now.com/api/now/table/sc_task?sysparm_query=number=${TASK}" > /dev/null
              echo "Closed and set Listserv CI for $TASK"
            else
              echo "Left $TASK open due to error: $RESULT"
            fi
          }
          # Process all 6 groups
          for g in {0..5}; do
            arr=$(jq ".[$g]" mailman_main_array_with_results.json)
            tasks=($(echo "$arr" | jq -r '.[0][]'))
            emails=($(echo "$arr" | jq -r '.[1][]'))
            results=($(echo "$arr" | jq -r '.[2][]'))
            count=${#tasks[@]}
            for idx in $(seq 0 $((count-1))); do
              t="${tasks[$idx]}"
              e="${emails[$idx]}"
              r="${results[$idx]}"
              update_task "$t" "Mailman: $e : $r" "$r"
            done
          done
